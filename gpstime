#!/bin/bash

# Set initial system time from raw GPS NMEA data, including from GPS's RTC
#
# Developed for the GlobalTop MTK3339/PA6H, but should work with other modules.

# Copyright (C) 2024 Timothe Litt litt _at acm.org
#
# MIT License.

# Syntax check changes with https://www.shellcheck.net/
# shellcheck disable=SC2016
VERSION='$Id$'

export LC_ALL="C"

# File marking GPS RTC as valid
RTCVALID="/var/lib/gpstime.rtcvalid"

# Current century (GPS only provides 2 digit years)
CC="20"

# Max year (avoid GPS loops - e.g. 060180 is common for cold start
MAXYR="75"

# Minimum year
MINYR="23"

# Maximum amount GPS time can go backward & still be valid (secs)
FUZZ=1800

# Minimum elapsed time before updating RTCVALID's timestamp (secs)
TSMIN=300

function usage() {
    cat <<EOF
Usage:
    gpstime [options] [device]

    Read time from a GPS (NMEA) device (stdin)

  Options:  (Defaults in parens)
    h      - This help
    l:n    - Maximum number of lines to read ($MAXTRYS)
    L:file - Log all received data to file, do not stop for or apply NMEA time.
    r:n    - Timeout for each device read ($TIMEOUT) secs
    s:n    - Set serial line speed (unchanged) bps & format
    S      - Set system time
    t:n    - Maximum time to wait for time ($LIMIT) secs
    v      - Verbose output
    V      - Print version of gpstime

  GlobalTop MT33xx commands
    F      - Send reset to factory defaults & cold restart command.  Clears RTC & configuration.
    C      - Send a cold restart command first - ignore position, almanac, ephemeris
    W      - Send a warm restart command first - ignore ephemeris
    R      - Send a hot restart command first - use all non-volatile data
    U:n    - Position (and time) update rate ($UPDATE) msec [100-10000], restart required.

  Lines are read from [device] until a valid message with
  the date and time is received.  Message checksums are
  verified.  Currently, only \$GPRMC is processed.

  Uninteresting / invalid lines are ignored.

  The GPS module doesn't report whether its RTC is valid.  When there is no fix, it will
  either report the RTC value, or if the RTC started without a fix, the uptime (and a random
  date).  The file $RTCVALID notes that this script has seen a valid fix, and assumes that
  the RTC date/time is valid.  However, if the RTC lost time (e.g. no battery), garbage can
  be used.  Thus, you should delete $RTCVALID or use -F if the battery dies.

  Example:
    Initialize & log output for 100 lines or 10 minutes from /dev/serial0:
      gpstime -C -Lgps.log -s9600 -l100 -t600 -v /dev/serial0

  Exit codes:
    0 - Success
    1 - No valid time found
    2 - Set system time failed

  Bug reports & contributions: https://github.com/tlhackque/rpi/issues

EOF
    return
}

# NMEA 0183 Talker IDs
#  Navigation: GA Galileo, GB BeiDou, GI NavIC, GL GLONASS, GN multiple, GP GPS, GQ QZSS
#  P* Proprietary

# Verify a NMEA string's checksum, which is the 2 hex digits following the '*'.
# This is the XOR of the ASCII characters between the '$' and the '*'.
# Additionally, the message type must match the allowed type(s).  E.g. 'GPXYZ|GPXYY'
# Return 0: Success, 1: Format error or wrong type, 2: Checksum error

function cksumOK() {
    local string="$1" types="$2" i len CKS=$((0x00))
    local -a CHRS

    # String must begin with "$" and end with *xx.  We don't check the line ending (CRLF).
    if [[ "$string" =~ ^'$'(($types),.+)'*'([[:xdigit:]]+) ]]; then
	# Isolate each character, convert to hex, and include in checksum
	# shellcheck disable=SC2207
	CHRS=($(grep -o '.' <<<"${BASH_REMATCH[1]}"))
	len=${#CHRS[@]}
	for ((i=0;i<len;i++)); do
	    CKS=$((CKS ^ $(printf '0x%02x' "'${CHRS[i]}")))
	done
	# Verify that computed checksum matches message
        # shellcheck disable=2309
	if [[ $CKS -eq 0x${BASH_REMATCH[3]} ]]; then
	    # Split the parameters for caller
	    # IFS=',' read -ra PARS <<<"${BASH_REMATCH[1]}"
	    return 0
	fi
	return 2
    fi
    return 1
}

# Wrap NMEA data with $ and * checksum (computed for data)

function makeMsg() {
    local body="$1" len i cks=$((0x00))
    local -a chrs

    # shellcheck disable=SC2207
    chrs=($(grep -o '.' <<<"$body"))
    len=${#chrs[@]}
    for ((i=0;i<len;i++)); do
        cks=$((cks ^ $(printf '0x%02x' "'${chrs[i]}")))
    done
    printf '\r\n$%s*%02X\r\n' "$body" "$cks"
    return 0
}

MON=('?' 'Jan' 'Feb' 'Mar' 'Apr' 'May' 'Jun' 'Jul' 'Aug' 'Sep' 'Oct' 'Nov' 'Dec')

# Device file to read from
DEV=
DEVSPD=
# Start time (secs)
STARTTIME="$(date +%s)"
# Maximum time to wait (secs)
LIMIT=30
# Maximum lines of input to read
MAXTRYS=10
# Timeout for each read (secs)
TIMEOUT=3

LOG=
INIT=
SET=
UPDATE=5000
VERBOSE=
while getopts "Fhl:L:r:s:St:TU:vVCRW" opt; do
    case "$opt" in
	h)
	    usage
	    exit
	    ;;
	l)
	    MAXTRYS="$OPTARG"
	    ;;
	L)
	    LOG="$OPTARG"
	    ;;
	r)
	    TIMEOUT="$OPTARG"
	    ;;
	s)
	    DEVSPD="$OPTARG"
	    ;;
	S)
	    SET=1
	    ;;
	t)
	    LIMIT="$OPTARG"
	    ;;
        T)
            INIT="PMTK000*32"
            ;;
        U)
            UPDATE="$OPTARG"
            ;;
	v)
	    VERBOSE=1
	    ;;
        V)
            if [[ "$VERSION" =~ ^'$''Id: '([[:xdigit:]]{4})([[:xdigit:]]{4})([[:xdigit:]]{4})([[:xdigit:]]{4})([[:xdigit:]]{4})([[:xdigit:]]{4})([[:xdigit:]]{4})([[:xdigit:]]{4})([[:xdigit:]]{4})([[:xdigit:]]{4})' $'$ ]]; then
                printf "gpstime version %s-%s-%s-%s\n" "${BASH_REMATCH[-4]}" "${BASH_REMATCH[-3]}" "${BASH_REMATCH[-2]}" "${BASH_REMATCH[-1]}"
                exit
            fi
            echo "gpstime version '$VERSION' - format error"
            exit 1
            ;;
	F)
	    INIT="PMTK104*37"
            rm -f "$RTCVALID"
	    ;;
	C)
	    INIT="PMTK103*30"
	    ;;
	R)
	    INIT="PMTK101*32"
	    ;;
	W)
	    INIT="PMTK102*31"
	    ;;

	*)
	    echo "Unknown option '$opt', -h for usage" >&2
	    exit 1
	    ;;
    esac
done
shift $((OPTIND-1))

STOPTIME=$(( STARTTIME + LIMIT ))

DEV="$1"
[ -n "$DEV" ] || DEV='/dev/fd/0'
[ -n "$DEVSPD" ] && stty -F "$DEV" raw "$DEVSPD" cs8 clocal -cstopb icrnl -echo

trap "exec 88>&-" EXIT
exec 88<>"$DEV"
if [ -n "$INIT" ]; then
    # Device is ready for command once it has sent data
    read -r -t"$TIMEOUT" DATA
    printf '\r\n$%s\r\n' "$INIT" >&88
fi

# Only enforce minimum update time if logging
[[ -z "$LOG" ]] && TSMIN=0

TRY=0
VALID=

while [[  TRY -lt MAXTRYS ]] && [[ $(date '+%s') -lt STOPTIME ]]; do
    read -r -t"$TIMEOUT" DATA || continue
    [ -n "$DATA" ] || continue
    TRY=$((TRY + 1))
    [ -n "$LOG" ] && printf '%3d: %s\n' "$TRY" "$DATA" >>"$LOG"
    # Talker G[NPAL} = Multiple|GPS|Galileo|GLONASS (BD|GB = Beidou)
    cksumOK "$DATA" "G[NPAL]RMC|PMTK01[01]|PMTK001|PMTK705|PGTOP" || continue

    # Process $G[NPAL]RMC: extract time (UTC), validity (A=vAlid, V=inValid), and date
    # Pars: UTC-time,Valid,LAT,NS,LON,EW,Speed,Course,Date,MagVar,EW,Mode
    # shellcheck disable=SC2026
    if [[ "$DATA" =~ ^'$'G[NPAL]RMC,([0-2][0-9])([0-6][0-9])([0-6][0-9])[.]([0-9]+),([AV]),[0-9.]*,[NS]?,[0-9.]*,[EW]?,[0-9.]*,[0-9.]*,([0-9][0-9])([0-9][0-9])([0-9][0-9]),[0-9.]*,[EW]?,[ADEMN]?'*'([[:xdigit:]]+) ]]; then
	VALID="${BASH_REMATCH[5]}"
	TIME="${BASH_REMATCH[1]}:${BASH_REMATCH[2]}:${BASH_REMATCH[3]}"
        if [[ "${BASH_REMATCH[8]}" -gt "$MAXYR" ]] || [[ "${BASH_REMATCH[8]}" -lt "$MINYR" ]]; then
            [[ -n "$VERBOSE" ]] && echo "Received unreasonable year ${BASH_REMATCH[8]}"
            continue
        fi
	DATE="${BASH_REMATCH[6]}-${MON[10#${BASH_REMATCH[7]}]}-${CC}${BASH_REMATCH[8]}"
        GPSTIMESTR="$DATE $TIME UTC"
        GPSTIME="$(date -d "$GPSTIMESTR" +%s 2>/dev/null)"

        LASTVALID="$(stat --printf=%Y "$RTCVALID" 2>/dev/null)"
	if [[ "$VALID" == 'A' ]]; then
            if [[ -z "$LASTVALID" ]] || [[ -n "$GPSTIME" && ( GPSTIME -gt $(( LASTVALID + TSMIN )) ) ]] ; then
                touch -d "$GPSTIMESTR" "$RTCVALID"
            fi
        else
            [[ -z "$LASTVALID" ]] || [[ GPSTIME -le $(( LASTVALID - FUZZ )) ]] ||  continue
        fi
	[ -n "$VERBOSE" ] && echo "Received $GPSTIMESTR ($(date -d "$GPSTIMESTR" +'%d-%b-%Y %T %Z')) after $TRY lines and $(( $(date +%s) - STARTTIME )) secs" >&2
	[ -n "$LOG" ] && continue
	if [ -n "$SET" ]; then
	    [ -n "$VERBOSE" ] && echo "Setting system time" >&2
	    if ! date -s "GPSTIMESTR"; then
		[ -n "$VERBOSE" ] && echo "Set time failed" >&2
		exit 2
	    fi
	fi
	exit 0
    fi
    # Command ACK/NAK
    # shellcheck disable=SC2016
    if [[ "$DATA" =~ ^'$PMTK001,'([0-9]+),([1-3])'*'([[:xdigit:]]+) ]]; then
        case "${BASH_REMATCH[2]}" in
            0)
                echo "GPS: Invalid command ${BASH_REMATCH[1]}" >&2
                ;;
            1)
                echo "GPS: Unsupported command/packet ${BASH_REMATCH[1]}" >&2
                ;;
            2)
                echo "GPS: Valid command ${BASH_REMATCH[1]} failed" >&2
                ;;
            3)
                [ -n "$VERBOSE" ] && echo "GPS: Valid command ${BASH_REMATCH[1]} succeeded" >&2
                ;;
            *)
                echo "GPS: invalid ACK code: ${BASH_REMATCH[2]} for ${BASH_REMATCH[1]}" >&2
        esac
        continue;
    fi
    # GPS "system message" (Power-up/restart)
    # shellcheck disable=SC2016
    if [[ "$DATA" =~ ^'$PMTK010,'([0-9]+)'*'([[:xdigit:]]+) ]]; then
        CODE=$((10#${BASH_REMATCH[1]}))
        case "$CODE" in
            0)
                [ -n "$VERBOSE" ] && echo "GPS: Unknown system message" >&2
                ;;
            1)
                if [ -n "$VERBOSE" ]; then
                    printf '\r\n$%s\r\n' "PMTK605*31" >&88
                    printf '\r\n$%s\r\n' 'PGTOP,11,3*6F' >&88
                    echo "GPS: Starting" >&2
                fi
                makeMsg "$(printf 'PMTK220,%u' "$UPDATE")" >&88
                ;;
            2)
                [ -n "$VERBOSE" ] && echo "GPS: EPO (offline orbit prediction data) notification" >&2
                ;;
            3)
                [ -n "$VERBOSE" ] && echo "GPS: Running normally" >&2
                ;;
            *)
                [ -n "$VERBOSE" ] && echo "GPS: Unknown system message code $CODE" >&2
                ;;                
        esac
        continue;
    fi
    # GPS "text message" (Power-up/restart)
    # shellcheck disable=SC2016
    if [[ "$DATA" =~ ^'$PMTK011,'([^*]+)'*'([[:xdigit:]]+) ]]; then
        [ -n "$VERBOSE" ] && echo "GPS: ${BASH_REMATCH[1]}" >&2
        continue;
    fi
    # GPS Firmware version
    # shellcheck disable=SC2016
    if [[ "$DATA" =~ ^'$PMTK705,'([^,]+),([^,]+),[^*]+'*'([[:xdigit:]]+) ]]; then
        [ -n "$VERBOSE" ] && echo "GPS: Firmware ${BASH_REMATCH[1]}, Build ${BASH_REMATCH[2]}" >&2
        continue;
    fi
    # Antenna status
    # Command ACK/NAK
    # shellcheck disable=SC2016
    if [[ "$DATA" =~ ^'$PGTOP,11,'([0-9]+)'*'([[:xdigit:]]+) ]]; then
        case "${BASH_REMATCH[1]}" in
            1)
                echo "GPS: External antenna is shorted" >&2
                ;;
            2)
                [ -n "$VERBOSE" ] && echo "GPS: Using internal (patch) antenna" >&2
                ;;
            3)
                [ -n "$VERBOSE" ] && echo "GPS: Using external antenna" >&2
                ;;
            *)
                [ -n "$VERBOSE" ] && echo "GPS: Unknown antenna status ${BASH_REMATCH[1]}" >&2
                ;;                
        esac
        continue;
    fi
done <&88

[ -n "$VERBOSE" ] && [ -z "$LOG" ] && echo "GPS/RTC time not found after $TRY lines and $(( $(date +%s) - STARTTIME )) secs" >&2
exit 1
